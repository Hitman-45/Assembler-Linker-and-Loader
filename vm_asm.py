#!/usr/bin/env python3
"""
VM Assembler — Module 1 + Module 2
----------------------------------
Module 1: Tokenize, parse assembly, generate instructions
Module 2: Emit object file (.vmo) with:
    - Header
    - .text section (code)
    - Symbol table (labels defined)
    - Relocation table (labels referenced but not defined locally)

File formats
============

Source: .vmasm (assembly)
Object: .vmo (object file)
Executable: .vmc (will be generated by linker in Module 3)

.vmo Layout (little endian):
----------------------------
Header (16 bytes):
  0..3   magic    = 'VMOF'
  4..5   version  = 0x0001
  6..7   flags    = reserved
  8..11  text_off = offset of code section
  12..15 text_len = length of code section

Then sections:
  [text section]
  [symbol table]
  [relocation table]

Symbol table entry (per symbol):
  u32 offset   — code offset
  u16 length   — name length
  char[name]   — name bytes (UTF-8)

Relocation entry:
  u32 offset   — code offset to patch
  u16 type     — relocation type (0=rel32)
  u16 length   — name length
  char[name]   — target symbol
"""
from __future__ import annotations
import argparse, os, re, struct, io, enum
from dataclasses import dataclass
from typing import List, Tuple, Dict, Optional

# -----------------------------
# Tokeniser (same as M1)
# -----------------------------
TOKEN_SPEC = [
    ("WS",       r"[ \t]+"),
    ("COMMENT",  r";.*"),
    ("DIRECTIVE",r"\.[A-Za-z_][A-Za-z0-9_]*"),
    ("LABEL",    r"[A-Za-z_][A-Za-z0-9_]*:"),
    ("REGISTER", r"(?:r|x)(?:[12]?\d|3[01]|\d)\b"),
    ("HEX",      r"0x[0-9A-Fa-f]+"),
    ("BIN",      r"0b[01]+"),
    ("INT",      r"-?\d+"),
    ("IDENT",    r"[A-Za-z_][A-Za-z0-9_]*"),
    ("COMMA",    r","),
    ("LBRACK",   r"\["),
    ("RBRACK",   r"\]"),
    ("PLUS",     r"\+"),
    ("NEWLINE",  r"\n+"),
]
TOKEN_RE = re.compile("|".join(f"(?P<{n}>{p})" for n,p in TOKEN_SPEC))

@dataclass
class Token:
    kind: str
    value: str
    line: int
    col: int

def lex(src: str) -> List[Token]:
    tokens: List[Token] = []
    line=1; col=1; i=0
    while i < len(src):
        m = TOKEN_RE.match(src,i)
        if not m:
            raise SyntaxError(f"Unknown token at {line}:{col}")
        kind,text = m.lastgroup,m.group(m.lastgroup)
        if kind=="NEWLINE":
            tokens.append(Token("NEWLINE","\n",line,col))
            line+=text.count("\n"); col=1
        elif kind in ("WS","COMMENT"):
            pass
        else:
            tokens.append(Token(kind,text,line,col))
            col+=len(text)
        i=m.end()
    tokens.append(Token("EOF","",line,col))
    return tokens

# -----------------------------
# ISA & IR
# -----------------------------
class Op(enum.Enum):
    LDI=1; MOV=2; ADD=3; SUB=4; AND=5; OR=6; XOR=7
    LW=8; SW=9; JMP=10; BEQ=11; BNE=12; CALL=13; RET=14; HALT=15

MNEMONIC = {k:v for k,v in {
    "ldi":Op.LDI,"mov":Op.MOV,"add":Op.ADD,"sub":Op.SUB,"and":Op.AND,"or":Op.OR,
    "xor":Op.XOR,"lw":Op.LW,"sw":Op.SW,"jmp":Op.JMP,"beq":Op.BEQ,"bne":Op.BNE,
    "call":Op.CALL,"ret":Op.RET,"halt":Op.HALT}.items()}

@dataclass
class Instr:
    op: Op; rd:int=0; rs1:int=0; rs2:int=0; imm:int=0
    label_ref: Optional[str]=None
    src_line:int=0

# -----------------------------
# Parser (pass 1)
# -----------------------------
class Parser:
    def __init__(self,toks:List[Token]):
        self.toks=toks; self.i=0
        self.labels:Dict[str,int]={}
        self.instrs:List[Instr]=[]
        self.relocs:List[Tuple[int,str]]=[]

    def at(self,k): return self.toks[self.i].kind==k
    def eat(self,k):
        t=self.toks[self.i]
        if t.kind!=k: raise SyntaxError(f"Expected {k}, got {t.kind} at {t.line}:{t.col}")
        self.i+=1; return t
    def maybe(self,k):
        if self.at(k): return self.eat(k)
        return None

    def parse(self)->Tuple[List[Instr],Dict[str,int],List[Tuple[int,str]]]:
        while not self.at("EOF"):
            if self.at("NEWLINE"): self.eat("NEWLINE"); continue
            if self.at("LABEL"):
                t=self.eat("LABEL"); name=t.value[:-1]
                self.labels[name]=len(self.instrs)*8
                self.maybe("NEWLINE"); continue
            if self.at("DIRECTIVE"):
                self.eat("DIRECTIVE")
                while not self.at("NEWLINE") and not self.at("EOF"): self.i+=1
                self.maybe("NEWLINE"); continue
            if self.at("IDENT"): self.parse_instr(); self.maybe("NEWLINE"); continue
            self.i+=1
        return self.instrs,self.labels,self.relocs

    def parse_reg(self): 
        t=self.eat("REGISTER"); return int(t.value[1:])
    def parse_int(self):
        t=self.toks[self.i]
        if t.kind=="HEX": self.i+=1; return int(t.value,16)
        if t.kind=="BIN": self.i+=1; return int(t.value,2)
        if t.kind=="INT": self.i+=1; return int(t.value,10)
        raise SyntaxError(f"Expected int at {t.line}:{t.col}")
    def expect_comma(self):
        if not self.maybe("COMMA"): raise SyntaxError("Expected ,")
    def parse_label_ref(self):
        t=self.toks[self.i]
        if t.kind=="IDENT": self.i+=1; return 0,t.value
        return self.parse_int(),None

    def parse_instr(self):
        mnem=self.eat("IDENT").value.lower()
        if mnem not in MNEMONIC: raise SyntaxError(f"Unknown mnemonic {mnem}")
        op=MNEMONIC[mnem]; line=self.toks[self.i-1].line
        rd=rs1=rs2=imm=0; lbl=None
        if op==Op.LDI: rd=self.parse_reg(); self.expect_comma(); imm=self.parse_int()
        elif op==Op.MOV: rd=self.parse_reg(); self.expect_comma(); rs1=self.parse_reg()
        elif op in (Op.ADD,Op.SUB,Op.AND,Op.OR,Op.XOR):
            rd=self.parse_reg(); self.expect_comma(); rs1=self.parse_reg(); self.expect_comma(); rs2=self.parse_reg()
        elif op==Op.LW: rd=self.parse_reg(); self.expect_comma(); self.eat("LBRACK"); rs1=self.parse_reg(); imm=0; self.eat("RBRACK")
        elif op==Op.SW: rs2=self.parse_reg(); self.expect_comma(); self.eat("LBRACK"); rs1=self.parse_reg(); imm=0; self.eat("RBRACK")
        elif op in (Op.JMP,Op.CALL): imm,lbl=self.parse_label_ref()
        elif op in (Op.BEQ,Op.BNE): rs1=self.parse_reg(); self.expect_comma(); rs2=self.parse_reg(); self.expect_comma(); imm,lbl=self.parse_label_ref()
        elif op in (Op.RET,Op.HALT): pass
        idx=len(self.instrs); self.instrs.append(Instr(op,rd,rs1,rs2,imm,lbl,line))
        if lbl: self.relocs.append((idx*8,lbl))

# -----------------------------
# Object File Writer (.vmo)
# -----------------------------
MAGIC=0x564D4F46 # 'VMOF'
VERSION=1

def assemble(src:str)->bytes:
    toks=lex(src); p=Parser(toks)
    instrs,labels,relocs=p.parse()
    code=bytearray()
    for inst in instrs:
        code+=struct.pack("<BBBBi",inst.op.value,inst.rd,inst.rs1,inst.rs2,inst.imm)
    text_off=16
    header=struct.pack("<IHHII",MAGIC,VERSION,0,text_off,len(code))
    out=bytearray(header); out+=code
    # symbol table
    for name,ofs in labels.items():
        nb=name.encode(); out+=struct.pack("<IH",ofs,len(nb)); out+=nb
    # reloc table
    for ofs,name in relocs:
        nb=name.encode(); out+=struct.pack("<IHH",ofs,0,len(nb)); out+=nb
    return bytes(out)

# -----------------------------
# CLI
# -----------------------------
def dump(b:bytes)->str:
    out=io.StringIO()
    for i in range(0,len(b),16):
        chunk=b[i:i+16]; hexs=" ".join(f"{x:02X}" for x in chunk)
        out.write(f"{i:08X}  {hexs}\n")
    return out.getvalue()

def main():
    ap=argparse.ArgumentParser(description="VM Assembler (Modules 1+2)")
    sub=ap.add_subparsers(dest="cmd",required=True)
    ap_a=sub.add_parser("assemble"); ap_a.add_argument("input"); ap_a.add_argument("-o","--output")
    ap_d=sub.add_parser("dump"); ap_d.add_argument("file")
    args=ap.parse_args()
    if args.cmd=="assemble":
        with open(args.input,"r",encoding="utf-8") as f: src=f.read()
        blob=assemble(src)
        out=args.output or os.path.splitext(args.input)[0]+".vmo"
        with open(out,"wb") as f: f.write(blob)
        print(f"Wrote {out} ({len(blob)} bytes)")
    elif args.cmd=="dump":
        with open(args.file,"rb") as f: b=f.read()
        print(dump(b))

if __name__=="__main__": main()
